---
title: "FHE Encrypted Operations"
description: "Complete guide to FHE types and operations for confidential smart contracts"
---

## Overview

The library exposes utility functions for FHE operations. The goal of the library is to provide a seamless developer experience for writing smart contracts that can operate on confidential data.

## Types

The library provides a type system that is checked both at compile time and at run time. The structure and operations related to these types are described in this section.

We currently support encrypted integers of bit length up to 128 bits and special types such as `ebool` and `eaddress`.

The encrypted integers behave as much as possible as Solidity's integer types. However, behavior such as "revert on overflow" is not supported as this would leak some information about the encrypted integers. Therefore, arithmetic on `euint` types is [unchecked](https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic), i.e. there is wrap-around on overflow.

In the back-end, encrypted integers are FHE ciphertexts. The library abstracts away the ciphertexts and presents pointers to ciphertexts, or ciphertext handles, to the smart contract developer. The `euint`, `ebool` and `eaddress` types are _wrappers_ over these handles.

### Supported Types

<CardGroup cols={2}>
<Card title="Compute Types">

| Name       | Bit Size | Usage   |
|------------|----------|---------|
| `euint8`   | 8        | Compute |
| `euint16`  | 16       | Compute |
| `euint32`  | 32       | Compute |
| `euint64`  | 64       | Compute |
| `euint128` | 128      | Compute |
| `ebool`    | 8        | Compute |
| `eaddress` | 160      | Compute |

</Card>

<Card title="Input Types">

| Name         | Bit Size | Usage |
|--------------|----------|-------|
| `InEuint8`   | 8        | Input |
| `InEuint16`  | 16       | Input |
| `InEuint32`  | 32       | Input |
| `InEuint64`  | 64       | Input |
| `InEuint128` | 128      | Input |
| `InEbool`    | 8        | Input |
| `InEaddress` | 160      | Input |

</Card>
</CardGroup>

<Note>
The `ebool` type is not a real boolean type. It is implemented as a `euint8` for compatibility with FHE operations.
</Note>

---

## Operations

There are two ways to perform operations with FHE.sol:

### Using Direct Function Calls

Direct function calls are the most straightforward way to perform operations with FHE.sol. For example, if you want to add two encrypted 8-bit integers (euint8), you can do so as follows:

```solidity
euint8 result = FHE.add(lhs, rhs);
```

Here, `lhs` and `rhs` are your `euint8` variables, and `result` will store the outcome of the addition.

### Using Library Bindings

FHE.sol also provides library bindings, allowing for a more natural syntax. To use this, you first need to include the library for your specific data type. For `euint8`, the usage would look like this:

```solidity
euint8 result = lhs.add(rhs);
```

In this example, `lhs.add(rhs)` performs the addition using the library function implicitly.

---

## Supported Operations

<Tip>
Complete documentation of every function in FHE.sol (including inputs and outputs) can be found in the [FHE.sol API Reference](/fhe-library/solidity-api/FHE).
</Tip>

All operations supported by FHE.sol are listed in the table below. Note that all functions are supported in both direct function calls and library bindings.

| Name                  | FHE.sol function | Operator | euint8 | euint16 | euint32 | euint64 | euint128 | ebool | eaddress |
|-----------------------|------------------|:--------:|:------:|:-------:|:-------:|:-------:|:--------:|:-----:|:--------:|
| Addition              | `add`            | `+`      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Subtraction           | `sub`            | `-`      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Multiplication        | `mul`            | `*`      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Bitwise And           | `and`            | `&`      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | No       |
| Bitwise Or            | `or`             | `\|`     | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | No       |
| Bitwise Xor           | `xor`            | `^`      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | No       |
| Division              | `div`            | `/`      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Remainder             | `rem`            | `%`      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Square                | `square`         | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Shift Right           | `shr`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Shift Left            | `shl`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Rotate Right          | `ror`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Rotate Left           | `rol`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Equal                 | `eq`             | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | Yes      |
| Not equal             | `ne`             | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | Yes      |
| Greater than or equal | `gte`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Greater than          | `gt`             | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Less than or equal    | `lte`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Less than             | `lt`             | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Min                   | `min`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Max                   | `max`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | No    | No       |
| Not                   | `not`            | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | No       |
| Select                | `select`         | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | Yes      |
| Decrypt               | `decrypt`        | n/a      | Yes    | Yes     | Yes     | Yes     | Yes      | Yes   | Yes      |

<Warning>
**Division and Remainder by `0`**: These operations will output an encrypted representation of the maximal value of the uint type being used (e.g., encrypted 255 for `euint8`). This behavior prevents information leakage about the divisor.
</Warning>

---

## Operation Examples

### Arithmetic Operations

```solidity
// Addition
euint32 sum = FHE.add(a, b);
// or using library binding
euint32 sum = a.add(b);

// Multiplication
euint32 product = FHE.mul(a, b);
```

### Comparison Operations

```solidity
// Returns an encrypted boolean (ebool)
ebool isGreater = FHE.gt(amount, threshold);
ebool isEqual = FHE.eq(value1, value2);
```

### Bitwise Operations

```solidity
// Bitwise AND
euint16 masked = FHE.and(flags, mask);

// Bitwise shifts
euint32 shifted = FHE.shl(value, 4); // Shift left by 4 bits
```

### Control Flow

```solidity
// Select between two values based on encrypted condition
euint32 result = FHE.select(condition, valueIfTrue, valueIfFalse);
```

<Tip>
Learn more about using encrypted conditionals in the [Select vs If-Else](/fhe-library/core-concepts/select-vs-ifelse) guide.
</Tip>
